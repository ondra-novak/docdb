#pragma once
#ifndef SRC_DOCDB_UTF8_H_
#define SRC_DOCDB_UTF8_H_

#include "concepts.h"
namespace docdb {

///Generated by chatgpt
template<typename OutputIterator>
OutputIterator wcharToUtf8(wchar_t wchar, OutputIterator output)
{
    int mode = (wchar > 0) + (wchar >= 0x80) + (wchar >= 0x800) + (wchar >= 0x10000) ;
    return number_to_constant<0,4>(mode, [&](auto v){
       if constexpr(!v.valid) {
           throw; //should never happen
       } else if constexpr(v.value == 0) { //to avoid single zero in sequence (Modified UTF-8)
           *output = static_cast<unsigned char>(0xC0);
           ++output;
           *output = static_cast<unsigned char>(0x80);
           ++output;
       } else if constexpr(v.value == 1) { //one byte
           *output = static_cast<char>(wchar);
           ++output;
       } else {
           constexpr int shift = v.value-1; // //two, three, for bytes
           constexpr unsigned char pfx = (0xF0 << (3-shift)) & 0xFF;
           constexpr unsigned char mask = static_cast<unsigned char>(~pfx) >> 1;
           unsigned char z = (static_cast<char>(wchar >> (shift*6)) & mask) | pfx;;
           *output = z;
           ++output;
           for (int i = 1; i < v.value; ++i) {
               z = static_cast<char>((wchar >> ((shift-i) * 6)) & 0x3F) | 0x80;
               *output = z;
               ++output;
           }
       }
       return output;
    });

#if 0
    if (wchar == 0) {  //to avoid single zero in sequence (Modified UTF-8)
        *output++ = 0xC0;
        *output++ = 0x80;
    } else if (wchar <= 0x7F) {
        *output++ = static_cast<char>(wchar);
    } else if (wchar <= 0x7FF) {
        *output++ = static_cast<char>((wchar >> 6) | 0xC0);
        *output++ = static_cast<char>((wchar & 0x3F) | 0x80);
    } else if (wchar <= 0xFFFF) {
        *output++ = static_cast<char>((wchar >> 12) | 0xE0);
        *output++ = static_cast<char>(((wchar >> 6) & 0x3F) | 0x80);
        *output++ = static_cast<char>((wchar & 0x3F) | 0x80);
    } else if (wchar <= 0x10FFFF) {
        *output++ = static_cast<char>((wchar >> 18) | 0xF0);
        *output++ = static_cast<char>(((wchar >> 12) & 0x3F) | 0x80);
        *output++ = static_cast<char>(((wchar >> 6) & 0x3F) | 0x80);
        *output++ = static_cast<char>((wchar & 0x3F) | 0x80);
    }
    return output;
#endif
}

template<typename InputIterator>
wchar_t utf8Towchar(InputIterator &at, InputIterator end) {
    unsigned char c = *at;
    ++at;
    int bytes = (c >= 0xC0) + (c >= 0xE0) + (c > 0xF0);
    return number_to_constant<0,3>(bytes, [&](auto b) ->wchar_t {
        if constexpr(!b.valid) {
            return static_cast<wchar_t>(c);
        } else if constexpr(b.value == 0) {
            return static_cast<wchar_t>(c);
        } else {
            wchar_t ret = static_cast<wchar_t>(c) & (0x3F >> b.value);
            for (int i = 0; i < b.value; i++) {
                if (at == end) return -1;
                unsigned char d = *at;
                ++at;
                ret = (ret << 6) | (d ^ 0x80);
            }
            return ret;
        }
    });
}

}




#endif /* SRC_DOCDB_UTF8_H_ */
